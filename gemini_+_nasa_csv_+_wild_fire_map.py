# -*- coding: utf-8 -*-
"""Gemini + Nasa csv + wild fire map.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fsTFBZrX7P26XyZ4xQ1oTMpyJEFajlUM
"""

# Commented out IPython magic to ensure Python compatibility.
# 🧩 Install necessary packages
# %pip install -U langchain langchain_community langchain-google-genai

# 🧠 Import Gemini LLM wrapper from LangChain
from langchain_google_genai import ChatGoogleGenerativeAI

# 🌐 Optional: LangSmith tracing (for observability and debugging)
import os
os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_ENDPOINT"] = "https://api.smith.langchain.com"
os.environ["LANGSMITH_API_KEY"] = "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"
os.environ["LANGSMITH_PROJECT"] = "pr-ordinary-snug-86"

# 🔑 Set your Google Gemini API key
os.environ["GOOGLE_API_KEY"] = "AIzaSyAsohY0NluKnkZ-eg0aWYUYO-c8GmF2JdE"

# 🤖 Instantiate Gemini model via LangChain
llm = ChatGoogleGenerativeAI(
    model="gemini-1.5-pro-latest",  # or "gemini-1.0-pro", "gemini-1.5-flash", etc.
    temperature=0.2,
    max_tokens=1024,
    max_retries=2,
)

# 💬 Use the model
response = llm.invoke("What's a good name for a productivity app?")
print(response.content)

!pip install -U langchain-google-genai
import os
import pandas as pd
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import initialize_agent, AgentType
from langchain.tools import tool

# 🔐 Set your Gemini API key
os.environ["GOOGLE_API_KEY"] = "AIzaSyAsohY0NluKnkZ-eg0aWYUYO-c8GmF2JdE"

# 📁 Local CSV path
FIRE_CSV_PATH = "/content/viirs-snpp_2023_United_States.csv"


@tool
def get_active_fires_from_csv(input: str) -> str:
    """
    Returns a summary of recent active wildfires in the USA from a local NASA FIRMS CSV file.
    The input is not used but required for LangChain tool compatibility.
    """
    try:
        df = pd.read_csv(FIRE_CSV_PATH)
        if df.empty:
            return "No wildfire data found in the CSV."

        preview = df.head(5).to_string(index=False)
        fire_count = len(df)
        latest_date = df['acq_date'].max() if 'acq_date' in df.columns else "unknown"

        return (
            f"🔥 Wildfire Snapshot from NASA FIRMS (CSV):\n"
            f"- Total active fire records: {fire_count}\n"
            f"- Latest record date: {latest_date}\n\n"
            f"📄 Sample data:\n{preview}"
        )
    except Exception as e:
        return f"Failed to read wildfire CSV data: {str(e)}"

# Initialize Gemini LLM
llm = ChatGoogleGenerativeAI(model="gemini-1.5-pro-latest", temperature=0)

# Register the tool
tools = [get_active_fires_from_csv]

# Initialize LangChain Agent
agent = initialize_agent(
    tools,
    llm,
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
)

# Run a test query
query = "Are there any current wildfires in the USA?"
response = agent.run(query)
print(response)

!pip install contextily
import geopandas as gpd
import contextily as ctx
import matplotlib.pyplot as plt
import seaborn as sns

wildfire_df = pd.read_csv("/content/viirs-snpp_2023_United_States.csv")

# Convert to GeoDataFrame using the actual DataFrame (not the file path string)
gdf = gpd.GeoDataFrame(
    wildfire_df,
    geometry=gpd.points_from_xy(wildfire_df.longitude, wildfire_df.latitude),
    crs="EPSG:4326"
)

# Project to Web Mercator for compatibility with basemap tiles
gdf = gdf.to_crs(epsg=3857)

# Plot
fig, ax = plt.subplots(figsize=(14, 10))

# Scatterplot over map
scatter = sns.scatterplot(
    x=gdf.geometry.x,
    y=gdf.geometry.y,
    hue=gdf["bright_ti4"],
    palette="hot",
    size=gdf["frp"],  # Fire Radiative Power affects point size
    sizes=(5, 50),
    alpha=0.6,
    linewidth=0,
    ax=ax,
    legend=False  # Legend can be very large; optional to show
)

# Add basemap
ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron, alpha=0.5)

# Tidy up the plot
ax.set_xticks([])
ax.set_yticks([])
ax.set_title("Wildfire Detections Across the United States (2023)", fontsize=16)
ax.set_xlabel("")
ax.set_ylabel("")

plt.show()